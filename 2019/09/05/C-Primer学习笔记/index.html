<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="a blog">
    <meta name="keyword" content="undefined">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          C++Primer学习笔记 - Blog of xzdDong
        
    </title>

    <link rel="canonical" href="http://yoursite.com/2019/09/05/C-Primer学习笔记/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS --> 
    <link rel="stylesheet" href="/css/beantech.min.css">
    
    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <link rel="stylesheet" href="/css/widget.css">

    <link rel="stylesheet" href="/css/rocket.css">

    <link rel="stylesheet" href="/css/signature.css">

    <link rel="stylesheet" href="/css/toc.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('header.jpg')
            /*post*/
        
    }
    
</style>

<header class="intro-header">
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#C++" title="C++">C++</a>
                            
                              <a class="tag" href="/tags/#学习笔记" title="学习笔记">学习笔记</a>
                            
                        </div>
                        <h1>C++Primer学习笔记</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by xzdDong on
                            2019-09-05
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Blog of xzdDong</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="内联"><a href="#内联" class="headerlink" title="内联"></a>内联</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><ul>
<li><p>内联函数声明也就是函数声明前加上关键字<code>inline</code>。</p>
</li>
<li><p>定义在类内部的成员函数自动inline。</p>
</li>
</ul>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>旨在告诉编译器希望编译时以内联的形式展开代码而非进行函数调用，以节省函数调用开销，而编译器可以选择忽略这一请求。一般适用于规模小、调用频繁、流程直接的函数。</p>
<h2 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h2><h3 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h3><p>在函数参数列表后加<code>const</code>关键字</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> Sales_data::avg_price() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(units_sold)&#123;</span><br><span class="line">        <span class="keyword">return</span> revenue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">avg_price</span><span class="params">()</span><span class="keyword">const</span> </span>;</span><br></pre></td></tr></table></figure>
<h3 id="作用"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>目前的简单理解：常量成员函数使用<code>const</code>的修饰后，保证不对传入的参数进行修改。实际上该修饰是向编译器指明传入的this指针（当前类的地址指针，隐式）是一个常量指针。</p>
<h3 id="可变数据mutable"><a href="#可变数据mutable" class="headerlink" title="可变数据mutable"></a>可变数据mutable</h3><p>可变数据声明前加上<code>mutable</code>关键字就表明其永远不会变为<code>const</code>，即使是在const函数中也可以对其进行修改。</p>
<h2 id="struct和class的区别"><a href="#struct和class的区别" class="headerlink" title="struct和class的区别"></a>struct和class的区别</h2><p>C++中这两种方式定义类的唯一区别是：</p>
<p><strong><em>默认的访问权限不同</em></strong></p>
<p>struct：默认为 public ；class 默认为private</p>
<h2 id="返回引用的函数"><a href="#返回引用的函数" class="headerlink" title="返回引用的函数"></a>返回引用的函数</h2><p>定义Person的成员函数如下，其中person是string的重命名；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span></span><br><span class="line">Person  &amp;Person::<span class="built_in">set</span>(<span class="keyword">const</span> person &amp;n,<span class="keyword">const</span> person &amp;a)&#123;</span><br><span class="line">    name = n;</span><br><span class="line">    address = a;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="keyword">const</span> Person  &amp;Person::display()<span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;name&lt;&lt;<span class="string">" :"</span>&lt;&lt;address&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="与返回对象本身的区别"><a href="#与返回对象本身的区别" class="headerlink" title="与返回对象本身的区别"></a>与返回对象本身的区别</h3><p>返回引用的函数即表明返回值是所调用对象本身，而非所调用对象的一个拷贝。</p>
<p>如果不加&amp;符号则表示返回了一个对象的拷贝，可能会造成对实际对象的操作无法正常完成，因为操作的对象变为了一个拷贝对象。</p>
<h3 id="返回常量指针的引用"><a href="#返回常量指针的引用" class="headerlink" title="返回常量指针的引用"></a>返回常量指针的引用</h3><p>对于第二个<code>display()</code>函数，由于其是常量成员函数(参数列表后有const声明),所以其返回的隐式指针<code>this</code>也是一个常量指针，所以函数应当返回的是一个常量引用。</p>
<p>对于返回*this的成员函数我们可以进行如下的动作序列调用，即先执行set后执行display。</p>
<p>而由于display返回的是常量引用，那么反过来的顺序就无法进行，因为set是一个针对非常量对象的函数，display执行后返回了常量对象，是无法进行进一步操作的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person someone;</span><br><span class="line">someone.<span class="built_in">set</span>(<span class="string">"xzddong"</span>,<span class="string">"Shanghai"</span>).display();<span class="comment">//正确</span></span><br><span class="line">someone.display().<span class="built_in">set</span>(<span class="string">"ming"</span>,<span class="string">"Beijing"</span>);<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>类的同名函数会作为构造函数，以在类声明时完成初始操作。如果不定义该函数，编译器会使用默认构造函数。</p>
<p>如果已定义自己的构造函数，使用default关键字的赋值也可以使用默认构造函数，构造函数是可以重载的。</p>
<p>构造函数按照类内初始值-&gt;默认初始值的原则来初始化。类内初始值就是在变量定义时就进行了初始化，但可能存在一些编译器不支持这种操作，此时就要用初始化列表来初始化。</p>
<p>下面是Person类中的构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//constructor</span></span><br><span class="line">Person() = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>
<h3 id="构造函数初始化值"><a href="#构造函数初始化值" class="headerlink" title="构造函数初始化值"></a>构造函数初始化值</h3><h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><p>在参数列表后，紧接<code>:</code>，之后就是对参数的初始化，其也是一种赋值的操作。</p>
<p>初始化顺序与其在类中的定义有关而非冒号后初始化代码的顺序。所以如果各个变量初始化之间有关联就要注意定义的顺序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;n,<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> a):name(n),address(a)&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="赋值初始化"><a href="#赋值初始化" class="headerlink" title="赋值初始化"></a>赋值初始化</h4><p>也就是在构造函数中进行赋值的定义。</p>
<p>但对于部分的类型比如说const类型无法进行赋值的操作，而且必须进行初始化（常量必须初始化），那么就采用初始化列表构建成员的初始值。</p>
<h2 id="迭代器的理解"><a href="#迭代器的理解" class="headerlink" title="迭代器的理解"></a>迭代器的理解</h2><p>初识迭代器，可以发现其和指针有点类似，迭代器在容器的概念之后介绍。</p>
<p>在c中，对于一个数组，我们可以使用指针来指向其任意一个元素的地址，并通过取值符号*来获取元素的值。</p>
<p>而迭代器也扮演着同样的角色，只不过对象包括vector，list等各种容器，容器是一系列对象的组合，并且部分容器无法像数组那样直接通过下标访问，那么迭代器就可以通用地解决问题，而通过*符号（这里叫做解引用符号）来进行取值。</p>
<p>在下例中，即使传参就是普通的迭代器，函数中对其值的修改也会影响实际的对象，这点更与指针的操作相似。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::<span class="function">iterator <span class="title">find_num_for_ex5</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter_begin,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter_end,<span class="keyword">const</span> <span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="comment">//vector&lt;int&gt;::iterator iter_tmp;</span></span><br><span class="line">    <span class="keyword">while</span>(iter_begin!= iter_end)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*iter_begin==a)&#123;</span><br><span class="line">            *(iter_end <span class="number">-1</span>) =<span class="number">999999999</span>;</span><br><span class="line">            <span class="keyword">return</span> iter_begin;</span><br><span class="line">        &#125;</span><br><span class="line">        iter_begin++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> iter_end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ex5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//iterator</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> i=<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">100</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*num.begin()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*find_num_for_ex5(num.begin(),num.end(),i)&lt;&lt;<span class="string">"end"</span>&lt;&lt;*(num.end()<span class="number">-1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于vector和数组来说，除了常见的++和–等操作，迭代器还可以相减，并且+n或-n，因为存储空间连续。</p>
<h3 id="const的容器"><a href="#const的容器" class="headerlink" title="const的容器"></a>const的容器</h3><p>对于未初始化的容器编译不会出错，但是可以发现这样其实是一个空元素，如果要通过迭代器<code>cnum.begin()</code>访问其中的值就等于访问一个不存在的指针一样，会出错。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnum;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;cnum.end()-cnum.begin()&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h3 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h3><p>是一种迭代器适配器，也就是说把容器适配成迭代器的形式，输入为容器，而返回的是迭代器。</p>
<p>分为三种：<code>back_inserter</code> <code>front_inserter</code> <code>inserter</code></p>
<p>其中前两个接受一个容器参数，最后一个 <code>inserter</code>接受第二个指定插入位置的迭代器参数，该插入迭代器将会将元素插入指定位置之前。</p>
<p>容器自带的insert成员操作也可以完成同样的工作。</p>
<p>与普通迭代器不同的是：对于插入迭代器的自增自减操作不会造成迭代器的变化。</p>
<p>值得注意的是：插入迭代器只能适用部分的容器，例如对于一些无法在首元素之前进行插入的容器如vector等，front_inserter无法使用。</p>
<h3 id="流迭代器"><a href="#流迭代器" class="headerlink" title="流迭代器"></a>流迭代器</h3><p>流迭代器顾名思义就是流的迭代器。</p>
<p>在如下对流的操作中，声明了一个默认初始化的流迭代器eof_iter，其可以作为流结束或出错的判断。</p>
<p>在while循环中push_back中，通过解引用取到流迭代器的旧值，后置自增使其定位到流的下一个输入。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">"text"</span>)</span></span>;</span><br><span class="line">   istream_iterator&lt;<span class="built_in">string</span>&gt; infs_iter(in);</span><br><span class="line">   istream_iterator&lt;<span class="built_in">string</span>&gt; eof_iter;</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; str_vec;</span><br><span class="line">   <span class="keyword">while</span>(infs_iter!=eof_iter)&#123;</span><br><span class="line">       str_vec.push_back(*infs_iter++);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">auto</span> s:str_vec) &#123;</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   in.close();</span><br></pre></td></tr></table></figure>
<p>以上代码还可以进行简化，在初始化就通过迭代器指定容器的范围。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">in.open(<span class="string">"text"</span>);</span><br><span class="line">   istream_iterator&lt;<span class="built_in">string</span>&gt; infs_iter2(in);</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; str_vec2(infs_iter2,eof_iter);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">auto</span> s:str_vec2) &#123;</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>lambda是一种可调用对象，类似于函数。</p>
<p>lambda的表达式如下，其中参数列表和返回类型可以省略，而返回类型必须通过尾置返回实现，也就是参数列表后用-&gt;符号指定。</p>
<p>其中捕获列表就是捕获外部的参数，起到函数的传参作用、</p>
<p><code>[捕获列表](参数列表)-&gt;返回类型{函数体}</code></p>
<h3 id="为什么需要lambda"><a href="#为什么需要lambda" class="headerlink" title="为什么需要lambda"></a>为什么需要lambda</h3><p>在进行对容器中元素的一系列算法操作函数中，有的可以传参二元谓词如sort，有的传参一元谓词如find_if、partition,谓词对于这些算法来说实际上就是一些自定义判断条件的函数，而一元、二元就代表这些函数的参数数量，这样算法可以根据需要传入自己排序或者判断的参数，也许是两个整数，也许是一个string。</p>
<p>如sort的前两个迭代器参数指定排序范围，第三个compare参数指定排序条件，返回bool类型。</p>
<p>而patition的compare参数则可只传入一个string，用于字符串划分。</p>
<p>而这样的话对于比如需要使用一元谓词的算法，通用性就大大降低了，因为每需要一个条件就要重写一个函数，因为对于谓词参数来说，无法通过函数传递更多的信息，其只允许传入一元、二元参数以便算法进行传参。</p>
<p>这时候lambda就可以发挥作用了，其可以通过捕获列表传入参数，通过参数列表指定元素，再通过函数体返回判断条件是否成功。如下就是find_if中传入lambda表达式找到字符串小于sz的迭代器位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> sz=<span class="number">6</span>;</span><br><span class="line"><span class="keyword">auto</span> first_element_iter2=find_if(svec2.begin(),svec2.end(),</span><br><span class="line">                                     [sz](<span class="keyword">const</span> <span class="built_in">string</span> s)&#123;<span class="keyword">return</span> s.size()&lt;sz;&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="参数绑定解决谓词参数传参的另一种方法"><a href="#参数绑定-解决谓词参数传参的另一种方法" class="headerlink" title="参数绑定:解决谓词参数传参的另一种方法"></a>参数绑定:解决谓词参数传参的另一种方法</h3><p>使用bind可以将一个函数的参数绑定到另一个函数上，并返回一个可调用的对象，算法函数在调用时可以明确知道应当将参数传入哪个当中。</p>
<h3 id="可变lambda"><a href="#可变lambda" class="headerlink" title="可变lambda"></a>可变lambda</h3><p>参数列表后加关键字mutable可以改变捕获列表的值，如下改变sz的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> sz=<span class="number">6</span>;</span><br><span class="line">    <span class="keyword">auto</span> first_element_iter2=find_if(svec2.begin(),svec2.end(),</span><br><span class="line">                             [sz](<span class="keyword">const</span> <span class="built_in">string</span> s)<span class="keyword">mutable</span>&#123;sz=<span class="number">5</span>;<span class="keyword">return</span> s.size()&lt;sz;&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a>拷贝控制</h2><h3 id="直接初始化和拷贝初始化"><a href="#直接初始化和拷贝初始化" class="headerlink" title="直接初始化和拷贝初始化"></a>直接初始化和拷贝初始化</h3><p>关于直接初始化和拷贝初始化的部分讲解<a href="https://blog.csdn.net/ljianhui/article/details/9245661" target="_blank" rel="noopener">https://blog.csdn.net/ljianhui/article/details/9245661</a></p>
<p>初始化分为直接初始化和拷贝初始化，一般的拷贝初始化出现在：</p>
<ul>
<li><p>直接用=赋值</p>
</li>
<li><p>用非引用形参的传递</p>
</li>
<li><p>返回非引用类型的对象</p>
</li>
<li><p>列表初始化</p>
</li>
</ul>
<p>直接初始化实际是由编译器来匹配构造函数完成初始化，而拷贝初始化就是由编译器将一个对象拷贝到正在创建的对象中。</p>
<p>从写法上看，直接初始化一般用变量后括号的形式如<code>int a(10);</code>这也符合函数调用的形式，但是直接初始化有时候也会调用拷贝构造函数，比如用一个对象初始化另一个对象<code>classA A(B);</code></p>
<p>所以要本质区别这两者可以这么理解：</p>
<ul>
<li><p>直接初始化就是匹配一个构造函数来进行初始化，不论这个函数是不是拷贝构造函数，它只要能匹配就会调用。</p>
</li>
<li><p>拷贝初始化在形式上表现为以上叙述的几种形式，但只要是拷贝初始化它就会以一个对象作为参数调用拷贝构造函数来完成这个操作，这个对象可以是一个已存在的对象，也可以说是由编译器构建的临时对象。</p>
</li>
</ul>
<h3 id="拷贝控制用来做什么"><a href="#拷贝控制用来做什么？" class="headerlink" title="拷贝控制用来做什么？"></a>拷贝控制用来做什么？</h3><p>在定义一个对象类的时候，需要指定此类型对象在拷贝、移动、赋值和销毁时要做什么，如果你不定义，编译器也会默认定义（一般编译器定义的称为合成的(synthesized) ，这些被定义的操作就称为拷贝控制，包含拷贝构造函数，拷贝赋值运算符，移动构造函数，移动赋值运算符，析构函数。简单理解，当一个对象被拷贝、移动、销毁时，就使用拷贝控制操作来完成。</p>
<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><ul>
<li><p>默认构造函数是进行自身构造时的初始化操作，也就是声明一个空的对象时进行构造</p>
</li>
<li><p>拷贝构造函数则就进行拷贝操作，也就是拷贝一个已存在的对象初始化一个新的对象。</p>
</li>
</ul>
<p>拷贝构造函数的参数必须是引用的，因为非引用传参也是一种拷贝操作，这个操作又需要拷贝构造函数来完成，这样就无限循环下去无法完成调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Foo();			<span class="comment">//默认构造函数</span></span><br><span class="line">	Foo(<span class="keyword">const</span> Foo&amp;);<span class="comment">//拷贝构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以下是C++ Primer练习13.5</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ Primer ex13.5</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数，默认实参为空string，用string的值初始化ps并分配动态内存，i初始化为10</span></span><br><span class="line">    HasPtr(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s=<span class="built_in">std</span>::<span class="built_in">string</span>()):ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(s)),i(<span class="number">10</span>)&#123;&#125;</span><br><span class="line">    <span class="comment">//拷贝构造函数，参数为类的引用</span></span><br><span class="line">    HasPtr(<span class="keyword">const</span> HasPtr &amp;c)&#123;</span><br><span class="line">        ps=<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(*c.ps);<span class="comment">//将被拷贝对象的值拷过来，而不是拷贝ps指针</span></span><br><span class="line">        i=c.i;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ps&lt;&lt;<span class="string">":"</span>&lt;&lt;*ps&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *ps;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ex9</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"xzd"</span>)</span></span>;</span><br><span class="line">    <span class="function">HasPtr <span class="title">h1</span><span class="params">(s1)</span></span>;</span><br><span class="line">    HasPtr h2 = h1;</span><br><span class="line">    h1.display();</span><br><span class="line">    h2.display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拷贝赋值"><a href="#拷贝赋值" class="headerlink" title="拷贝赋值"></a>拷贝赋值</h3><p>拷贝构造与拷贝赋值的区别在于</p>
<ul>
<li><p>拷贝构造函数在构造时调用，也就是这个对象还没完成定义的时候</p>
</li>
<li><p>拷贝赋值操作符重载则在赋值时调用，也就是该对象已经存在。</p>
</li>
</ul>
<p>将上面的练习13.5的代码改一下，加入操作运算符=的重载，注意这里构造的函数并不安全，因为它无脑拷贝了指针成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ Primer ex13.5</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HasPtr()=<span class="keyword">default</span>;</span><br><span class="line">    HasPtr(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s=<span class="built_in">std</span>::<span class="built_in">string</span>()):ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(s)),i(<span class="number">10</span>)&#123;&#125;</span><br><span class="line">    <span class="comment">//重载赋值运算符</span></span><br><span class="line">    HasPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr &amp;c)&#123;</span><br><span class="line">        ps=c.ps;</span><br><span class="line">        i=c.i;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HasPtr(<span class="keyword">const</span> HasPtr &amp;c)&#123;</span><br><span class="line">        ps=<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(*c.ps);</span><br><span class="line">        i=c.i;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ps&lt;&lt;<span class="string">":"</span>&lt;&lt;*ps&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *ps;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ex9</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"xzd"</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">"dsa"</span>)</span></span>;</span><br><span class="line">    <span class="function">HasPtr <span class="title">h1</span><span class="params">(s1)</span></span>;<span class="comment">//调用了默认构造</span></span><br><span class="line">    HasPtr h2 = h1;<span class="comment">//调用了拷贝构造</span></span><br><span class="line">    <span class="function">HasPtr <span class="title">h3</span><span class="params">(s2)</span></span>;<span class="comment">//调用了默认构造</span></span><br><span class="line">    h3 = h2;	<span class="comment">//调用了拷贝赋值</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;&amp;s1&lt;&lt;<span class="string">":"</span>&lt;&lt;s1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    h1.display();</span><br><span class="line">    h2.display();</span><br><span class="line">    h3.display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>与构造函数相对</p>
<p>构造函数：初始化成员-&gt;执行构造函数</p>
<p>析构函数：执行析构函数-&gt;按初始化顺序销毁成员（自动进行，取决于成员是什么类型）</p>
<h3 id="三五法则"><a href="#三五法则" class="headerlink" title="三五法则"></a>三五法则</h3><p>前面已经提到三种拷贝控制操作，如果未定义，编译器会生成合成的拷贝操作，一般情况下，当有析构函数时，拷贝和赋值也应当存在，比如当类中存在动态内存分配，我们需要析构函数来delete内存，若此时没有自定义的拷贝赋值操作，默认的拷贝赋值会导致多个对象指向同一块内存，因为合成的拷贝赋值简单地拷贝指针成员，那么当多个对象销毁时，就会造成多次删除同一块内存导致未知错误。</p>
<h3 id="阻止拷贝"><a href="#阻止拷贝" class="headerlink" title="阻止拷贝"></a>阻止拷贝</h3><p><strong>=delete</strong></p>
<p>在一些情况下，我们不希望自己的类具有拷贝操作，那么可以定义这些操作后面加上=delete来告诉编译器，除了析构函数，其他函数都可以做这个声明。</p>
<p><strong>private</strong></p>
<p>将拷贝操作声明为private是一种旧方法，因为这样编译器不会生成public的合成拷贝操作，外部也无法调用拷贝操作来进行构造，以达到阻止拷贝的目的。正确的还是应当用=delete来定义。</p>
<h3 id="行为像值的类"><a href="#行为像值的类" class="headerlink" title="行为像值的类"></a>行为像值的类</h3><p>行为像值的类，类似于string，对象之间不受影响，那么这个实现值得注意的是重载赋值运算符，必须保证对象赋值给自身时也能正确工作，所以以上的类中拷贝赋值可以改成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HasPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr &amp;c)&#123;</span><br><span class="line">       <span class="keyword">auto</span> tmp = *c.ps;</span><br><span class="line">       <span class="keyword">delete</span> ps;<span class="comment">//delete在后，保证自赋值也能正确工作</span></span><br><span class="line">       ps=<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(tmp);</span><br><span class="line">       i=c.i;</span><br><span class="line">       <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>还要增加析构函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~HasPtr()&#123;<span class="keyword">delete</span> ps;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="行为像指针的类"><a href="#行为像指针的类" class="headerlink" title="行为像指针的类"></a>行为像指针的类</h3><p>那么对于类中的指针成员要拷贝地址而不是值，那么就需要进行管理以防止重复删除或者其他不当操作，可以采用智能指针的引用计数方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~HasPtr()&#123;</span><br><span class="line">        <span class="keyword">if</span>(--*count==<span class="number">0</span>)&#123;<span class="comment">//计数为0了才释放</span></span><br><span class="line">            <span class="keyword">delete</span> ps;</span><br><span class="line">            <span class="keyword">delete</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    HasPtr(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s=<span class="built_in">std</span>::<span class="built_in">string</span>()):ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(s)),i(<span class="number">10</span>),count(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="keyword">size_t</span>(<span class="number">1</span>))&#123;&#125;</span><br><span class="line">    HasPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr &amp;c)&#123;</span><br><span class="line">        ++*c.count;</span><br><span class="line">        <span class="keyword">if</span>(--*count==<span class="number">0</span>)&#123;<span class="comment">//先释放原来的</span></span><br><span class="line">            <span class="keyword">delete</span> ps;</span><br><span class="line">            <span class="keyword">delete</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">        ps=c.ps;</span><br><span class="line">        i=c.i;</span><br><span class="line">        count = c.count;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HasPtr(<span class="keyword">const</span> HasPtr &amp;c)&#123;</span><br><span class="line">        ps=c.ps;</span><br><span class="line">        i=c.i;</span><br><span class="line">        count=c.count;</span><br><span class="line">        ++*count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ps&lt;&lt;<span class="string">":"</span>&lt;&lt;*ps&lt;&lt;<span class="string">" count:"</span>&lt;&lt;*count&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *ps;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> *count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ex9</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"xzd"</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">"dsa"</span>)</span></span>;</span><br><span class="line">    <span class="function">HasPtr <span class="title">h1</span><span class="params">(s1)</span></span>;</span><br><span class="line">    HasPtr h2 = h1;</span><br><span class="line">    <span class="function">HasPtr <span class="title">h3</span><span class="params">(s2)</span></span>;</span><br><span class="line">    h3 = h2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;&amp;s1&lt;&lt;<span class="string">":"</span>&lt;&lt;s1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    h1.display();</span><br><span class="line">    h2.display();</span><br><span class="line">    h3.display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h3><p>std中有swap的标准操作，但其对于任何对象都执行了拷贝，赋值，拷贝的操作，有时候我们希望自己来定义交换操作，交换两者的指针以减少拷贝过程中带来的开销。</p>
<p>在匹配过程中如果不指定swap的空间如<code>std::swap</code>那么类型内定的swap操作总会优先于标准库的swap进行匹配。</p>
<p>另外值得一提的是，如果一个对象定义了自己的swap操作，就可以利用 自己的swap做赋值运算符重载，如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HasPtr&amp; <span class="keyword">operator</span>=(HasPtr c)&#123;</span><br><span class="line">       swap(*<span class="keyword">this</span>,c);</span><br><span class="line">       <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>其满足自赋值要求。</p>
<h3 id="关于移动语义"><a href="#关于移动语义" class="headerlink" title="关于移动语义"></a>关于移动语义</h3><p><a href="https://www.cnblogs.com/qicosmos/p/4283455.html" target="_blank" rel="noopener">这篇博客讲的较清楚</a></p>
<p>暂未深入了解，只做简单理解。</p>
<p>拷贝控制中除了拷贝构造、拷贝赋值、析构以外，新标准中加入了移动赋值和移动构造。</p>
<p><strong>为什么要加入移动操作</strong>？</p>
<p>设想这样一种情况，我们有一个对象，它占据了大量内存空间，比如里面我们申请了一个超大的数组，那么当我们以一个临时对象进行拷贝或者赋值操作的时候，会调用拷贝构造或拷贝赋值，那么我们就需要对一个大的资源进行深拷贝操作，因为临时对象在拷贝赋值完成后就会被销毁，这样的深拷贝操作是消耗性能的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="function">A&amp; <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">A a=f();</span><br></pre></td></tr></table></figure>
<p>优化的思路就是我们保持这个构建的临时变量，使其可以不被销毁，并且在函数中只进行浅拷贝。</p>
<p>针对这种情况，移动操作的好处就体现出来了。</p>
<p>那么为了支持这种操作，就提出了右值引用的概念。</p>
<p>这里涉及一个左值和右值的概念，简单理解，左值就是固定住所(是一个确定的内存对象)，右值就是旅馆(临时构建的对象)，判断方式就是左值是可以取地址的，比如变量，右值是无法取地址的，比如函数返回值，字面常量，这些值生命周期短暂。</p>
<p>右值引用 采用<code>&amp;&amp;</code>符号获取，其实际上也是一种引用，与左值引用&amp;所不同的是，它所引用的对象就是右值，因为左值引用是无法对右值进行引用的。右值引用使得右值的生命周期变长，也就是强行续命的意思，其所引用的资源就由右值引用的代码接管了。</p>
<p>再回到以上的情况，当我们在类中定义了移动构造函数，其实也就是构造函数的一个重载，至于你在里面做什么完全由你自己决定。当我们用一个临时对象构造新的对象时，如以下函数表达式是返回右值，那么要构造的对象就会调用移动构造函数（匹配右值引用）,那么我们就可以在这个构造函数中完成我们需要的浅拷贝，避免深拷贝带来的性能消耗。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    A(<span class="keyword">const</span> A&amp;&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A&amp; <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">A a=f();</span><br></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="基类和子类的转换"><a href="#基类和子类的转换" class="headerlink" title="基类和子类的转换"></a>基类和子类的转换</h3><p><a href="https://www.cnblogs.com/piginthetree/p/3891885.html" target="_blank" rel="noopener">https://www.cnblogs.com/piginthetree/p/3891885.html</a></p>
<p><a href="https://blog.csdn.net/dcrmg/article/details/83472660?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight" target="_blank" rel="noopener">https://blog.csdn.net/dcrmg/article/details/83472660?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight</a></p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>const不可修饰引用，引用本身不可修改，引用建立了一个栈上的常量指针。</p>
<p><a href="https://www.cnblogs.com/Royzzzzz/articles/10959831.html" target="_blank" rel="noopener">https://www.cnblogs.com/Royzzzzz/articles/10959831.html</a></p>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="null和nullptr"><a href="#NULL和nullptr" class="headerlink" title="NULL和nullptr"></a>NULL和nullptr</h2><p>c++不支持void<em>指针的隐式转换，在c中NULL被宏定义为void\</em>空指针而C++中NULL只是0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void *)0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>在C++函数重载时，NULL实际传入的是0，会造成二义性，所以C++11中引入nullptr作为关键字，在新标准说明中，一个指向空的指针要么是一个字面值整形，要么是一个std::nullptr_t，其可以转换为空指针类型。、</p>
<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><h2 id="顺序容器vector相关操作"><a href="#顺序容器vector相关操作" class="headerlink" title="顺序容器vector相关操作"></a>顺序容器vector相关操作</h2><p><a href="http://c.biancheng.net/view/429.html" target="_blank" rel="noopener">http://c.biancheng.net/view/429.html</a></p>
<p>头文件包含</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="sort排序"><a href="#sort排序" class="headerlink" title="sort排序"></a>sort排序</h3><p>sort()函数，可重载，全局函数，需包含<code>#include &lt;algorithm&gt;</code>。</p>
<p>1.输入指定迭代器范围（开始，结束）</p>
<p>2.输入指定迭代器范围和比较函数（开始，结束，比较函数）</p>
<p>3.输入指定迭代器范围和比较类（开始，结束，比较类）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sort algorithm example</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;     // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;    // std::sort</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;       // std::vector</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myfunction</span> <span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> (i&lt;j); &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myclass</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> (i&lt;j);&#125;</span><br><span class="line">&#125; myobject;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> myints[] = &#123;<span class="number">32</span>,<span class="number">71</span>,<span class="number">12</span>,<span class="number">45</span>,<span class="number">26</span>,<span class="number">80</span>,<span class="number">53</span>,<span class="number">33</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (myints, myints+<span class="number">8</span>);       <span class="comment">// 32 71 12 45 26 80 53 33</span></span><br><span class="line">  <span class="comment">// using default comparison (operator &lt;)</span></span><br><span class="line">  <span class="built_in">std</span>::sort (myvector.begin(), myvector.begin()+<span class="number">4</span>);     <span class="comment">//(12 32 45 71)26 80 53 33</span></span><br><span class="line">  <span class="comment">// using function as comp</span></span><br><span class="line">  <span class="built_in">std</span>::sort (myvector.begin()+<span class="number">4</span>, myvector.end(), myfunction); <span class="comment">// 12 32 45 71(26 33 53 80)</span></span><br><span class="line">  <span class="comment">// using object as comp</span></span><br><span class="line">  <span class="built_in">std</span>::sort (myvector.begin(), myvector.end(), myobject); <span class="comment">//(12 26 32 33 45 53 71 80)</span></span><br><span class="line">  <span class="comment">// print out content:</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myvector contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=myvector.begin(); it!=myvector.end(); ++it)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于sort为全局函数，sort中的比较函数compare要声明为<strong>静态成员函数</strong>或<strong>全局函数</strong>，<strong>不能作为普通成员函数</strong>，即不可以写在类中；如果写在类中，也需要加<code>static</code>关键字，否则会报错：invalid use of non-static member function</p>
<h3 id="最大最小值和位置索引"><a href="#最大最小值和位置索引" class="headerlink" title="最大最小值和位置索引"></a>最大最小值和位置索引</h3><p>最大值max_element()  最小值min_element()  索引distance()。需包含<code>#include &lt;algorithm&gt;</code>。</p>
<h3 id="作为类成员变量的初始化"><a href="#作为类成员变量的初始化" class="headerlink" title="作为类成员变量的初始化"></a>作为类成员变量的初始化</h3><p>当使用vector作为类成员变量时，不能使用<code>vector&lt;int&gt; a(10)</code>的方式初始化，可能因为编译器可能会把它当作函数声明。正确的做法如下：</p>
<p>1.使用初始化列表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; num&#123;<span class="string">""</span>,<span class="string">""</span>,<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,<span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>2.c++11之后可以赋值初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">class <span class="title">Foo</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; name = <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; val&#123;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>,<span class="number">0</span>)&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.C++11之前可以采用构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; name;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; val;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Foo() : name(<span class="number">5</span>), val(<span class="number">5</span>,<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>vector的查找使用find全局函数。vector没有find的成员函数，这是由于对于其他数据结构如map和set，其使用红黑树提供，可以使用更加高效的查找方法，所以自定义了find。通用find模板如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">InputIterator</span> <span class="title">find</span> (<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">val</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">while</span> (first!=last) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*first==val) <span class="keyword">return</span> first;</span><br><span class="line">    ++first;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于sting类型的find成员函数可以通过a.find(val)==string::npos判断是否查找结束，string::npos是一种string::size_type类型的值，为-1,所有string的find类型的成员函数均返回该值。</p>
<h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>priority_queue</p>
<p>其使用堆来维护，按优先级先入先出，默认为大顶堆，最大值在堆顶，降序排列所以用less。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="comment">//等同于 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; q;</span></span><br></pre></td></tr></table></figure>
<p>小顶堆,最小值在堆顶，升序排列所以用greater。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br></pre></td></tr></table></figure>
<h2 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h2><h3 id="按key排序"><a href="#按key排序" class="headerlink" title="按key排序"></a>按key排序</h3><p><a href="https://www.cnblogs.com/lakeone/p/5599047.html" target="_blank" rel="noopener">https://www.cnblogs.com/lakeone/p/5599047.html</a></p>
<p>关联容器默认按照key升序排列，实际上也可以指定参数，比如对于map，可以指定第三个参数为比较参数，官方提供了两个函数模板分别是greater<t>和less<t>对应降序和升序，默认的情况就是less<t>,T就是key的类型。也可以自己指定比较参数，只需要传入函数指针就行了，并且在声明该容器时传入对应的函数指针。</t></t></t></p>
<p>以下是三种写法，由decltype获取的是函数类型，而非指针，所以要加上*表示指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sort_by_key</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">decltype</span>(sort_by_key)*&gt; n(sort_by_key);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">bool</span> <span class="title">map_f</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,map_f*&gt; m(sort_by_key); <span class="comment">//not use decltype</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(map_fp*)</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,map_fp&gt; m(sort_by_key); <span class="comment">//not use decltype</span></span><br></pre></td></tr></table></figure>
<h3 id="按value排序"><a href="#按value排序" class="headerlink" title="按value排序"></a>按value排序</h3><p>只能通过sort函数来解决，也就是遍历map后存一个pair的vector,然后构造自己的比较函数，以value来排序。</p>
<h1 id="oop"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h1><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>每个类控制各自成员的初始化过程 ，所以派生类的构造函数要初始化基类成员就调用基类构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Basic</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Basic(<span class="keyword">int</span> m):price(m)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;price&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derivation1</span>:</span><span class="keyword">public</span> Basic&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derivation1(<span class="keyword">int</span> m):Basic(m)&#123;&#125;        </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="继承类型"><a href="#继承类型" class="headerlink" title="继承类型"></a>继承类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;派生类名&gt;:</span>&lt;继承类型<span class="number">1</span>&gt;&lt;基类名<span class="number">1</span>&gt;,&lt;继承类型<span class="number">2</span>&gt;&lt;基类名<span class="number">2</span>&gt;,…</span><br><span class="line">&#123;</span><br><span class="line">&lt;派生类类体&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>继承类型关键字同类访问权限一样：public  protected  private</p>
<p>继承类型就约束了继承的权限，通常就使用public，几乎不用其他两种。</p>
<p>public：维持基类的成员访问权限。</p>
<p>protected：把基类public和protected的成员都变为protected</p>
<p>private：把基类public和protected的成员都变为private</p>
<h2 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h2><p>多个类有继承关系的话，带有这些类的参数的函数在运行时才决定参数采用哪个类，·具体执行的是哪个类的版本就取决于实参类型了。</p>
<p>运行时才绑定参数类型，就叫做动态绑定了。</p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>动态绑定的实现依赖于虚函数。</p>
<p>虚函数关键字virtual</p>
<h3 id="纯虚函数与抽象基类"><a href="#纯虚函数与抽象基类" class="headerlink" title="纯虚函数与抽象基类"></a>纯虚函数与抽象基类</h3><p>对一个函数，当基类希望不同子类有不同实现，而基类不需要有明显实现，可以定义为纯虚函数，只需要在虚函数后面加上=0。</p>
<p>含有纯虚函数的类是抽象基类，因为它只提供了接口，而不负责实现，这样的类是不能创建对象的。</p>
<p>纯虚函数也是可以定义的，能且只能在类外定义。</p>
<h1 id="流"><a href="#流" class="headerlink" title="流"></a>流</h1><p>标准输入cin会跳过空格，回车，tab直到输入类型匹配，但不会消除之后的流，比如“123  456”在cin&gt;&gt;int之后流中应剩余“ 456”空格还留在流中。</p>

                

                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/2019/09/18/杂七杂八/" data-toggle="tooltip" data-placement="top" title="杂七杂八">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/2019/08/18/lighttpd学习/" data-toggle="tooltip" data-placement="top" title="lighttpd学习">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                <!-- duoshuo Share start -->
                
                <!-- 多说 Share end-->

                <!-- 多说评论框 start -->
                
                <!-- 多说评论框 end -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->
            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#类"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">类</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#内联"><span class="toc-nav-number">1.1.</span> <span class="toc-nav-text">内联</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#声明"><span class="toc-nav-number">1.1.1.</span> <span class="toc-nav-text">声明</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#作用"><span class="toc-nav-number">1.1.2.</span> <span class="toc-nav-text">作用</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#常量成员函数"><span class="toc-nav-number">1.2.</span> <span class="toc-nav-text">常量成员函数</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#形式"><span class="toc-nav-number">1.2.1.</span> <span class="toc-nav-text">形式</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#例子"><span class="toc-nav-number">1.2.2.</span> <span class="toc-nav-text">例子</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#作用"><span class="toc-nav-number">1.2.3.</span> <span class="toc-nav-text">作用</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#可变数据mutable"><span class="toc-nav-number">1.2.4.</span> <span class="toc-nav-text">可变数据mutable</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#struct和class的区别"><span class="toc-nav-number">1.3.</span> <span class="toc-nav-text">struct和class的区别</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#返回引用的函数"><span class="toc-nav-number">1.4.</span> <span class="toc-nav-text">返回引用的函数</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#与返回对象本身的区别"><span class="toc-nav-number">1.4.1.</span> <span class="toc-nav-text">与返回对象本身的区别</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#返回常量指针的引用"><span class="toc-nav-number">1.4.2.</span> <span class="toc-nav-text">返回常量指针的引用</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#构造函数"><span class="toc-nav-number">1.5.</span> <span class="toc-nav-text">构造函数</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#构造函数初始化值"><span class="toc-nav-number">1.5.1.</span> <span class="toc-nav-text">构造函数初始化值</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#初始化列表"><span class="toc-nav-number">1.5.1.1.</span> <span class="toc-nav-text">初始化列表</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#赋值初始化"><span class="toc-nav-number">1.5.1.2.</span> <span class="toc-nav-text">赋值初始化</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#迭代器的理解"><span class="toc-nav-number">1.6.</span> <span class="toc-nav-text">迭代器的理解</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#const的容器"><span class="toc-nav-number">1.6.1.</span> <span class="toc-nav-text">const的容器</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#插入迭代器"><span class="toc-nav-number">1.6.2.</span> <span class="toc-nav-text">插入迭代器</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#流迭代器"><span class="toc-nav-number">1.6.3.</span> <span class="toc-nav-text">流迭代器</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#lambda表达式"><span class="toc-nav-number">1.7.</span> <span class="toc-nav-text">lambda表达式</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#为什么需要lambda"><span class="toc-nav-number">1.7.1.</span> <span class="toc-nav-text">为什么需要lambda</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#参数绑定解决谓词参数传参的另一种方法"><span class="toc-nav-number">1.7.2.</span> <span class="toc-nav-text">参数绑定:解决谓词参数传参的另一种方法</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#可变lambda"><span class="toc-nav-number">1.7.3.</span> <span class="toc-nav-text">可变lambda</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#拷贝控制"><span class="toc-nav-number">1.8.</span> <span class="toc-nav-text">拷贝控制</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#直接初始化和拷贝初始化"><span class="toc-nav-number">1.8.1.</span> <span class="toc-nav-text">直接初始化和拷贝初始化</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#拷贝控制用来做什么"><span class="toc-nav-number">1.8.2.</span> <span class="toc-nav-text">拷贝控制用来做什么？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#拷贝构造函数"><span class="toc-nav-number">1.8.3.</span> <span class="toc-nav-text">拷贝构造函数</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#拷贝赋值"><span class="toc-nav-number">1.8.4.</span> <span class="toc-nav-text">拷贝赋值</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#析构函数"><span class="toc-nav-number">1.8.5.</span> <span class="toc-nav-text">析构函数</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#三五法则"><span class="toc-nav-number">1.8.6.</span> <span class="toc-nav-text">三五法则</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#阻止拷贝"><span class="toc-nav-number">1.8.7.</span> <span class="toc-nav-text">阻止拷贝</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#行为像值的类"><span class="toc-nav-number">1.8.8.</span> <span class="toc-nav-text">行为像值的类</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#行为像指针的类"><span class="toc-nav-number">1.8.9.</span> <span class="toc-nav-text">行为像指针的类</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#swap"><span class="toc-nav-number">1.8.10.</span> <span class="toc-nav-text">swap</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#关于移动语义"><span class="toc-nav-number">1.8.11.</span> <span class="toc-nav-text">关于移动语义</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#继承"><span class="toc-nav-number">1.9.</span> <span class="toc-nav-text">继承</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#基类和子类的转换"><span class="toc-nav-number">1.9.1.</span> <span class="toc-nav-text">基类和子类的转换</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#变量"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">变量</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#常量"><span class="toc-nav-number">2.1.</span> <span class="toc-nav-text">常量</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#指针"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">指针</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#null和nullptr"><span class="toc-nav-number">3.1.</span> <span class="toc-nav-text">NULL和nullptr</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#容器"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">容器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#顺序容器vector相关操作"><span class="toc-nav-number">4.1.</span> <span class="toc-nav-text">顺序容器vector相关操作</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#sort排序"><span class="toc-nav-number">4.1.1.</span> <span class="toc-nav-text">sort排序</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#最大最小值和位置索引"><span class="toc-nav-number">4.1.2.</span> <span class="toc-nav-text">最大最小值和位置索引</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#作为类成员变量的初始化"><span class="toc-nav-number">4.1.3.</span> <span class="toc-nav-text">作为类成员变量的初始化</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#查找"><span class="toc-nav-number">4.1.4.</span> <span class="toc-nav-text">查找</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#容器适配器"><span class="toc-nav-number">4.2.</span> <span class="toc-nav-text">容器适配器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#优先队列"><span class="toc-nav-number">4.2.1.</span> <span class="toc-nav-text">优先队列</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#关联容器"><span class="toc-nav-number">4.3.</span> <span class="toc-nav-text">关联容器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#按key排序"><span class="toc-nav-number">4.3.1.</span> <span class="toc-nav-text">按key排序</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#按value排序"><span class="toc-nav-number">4.3.2.</span> <span class="toc-nav-text">按value排序</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#oop"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">OOP</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#构造"><span class="toc-nav-number">5.1.</span> <span class="toc-nav-text">构造</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#继承类型"><span class="toc-nav-number">5.2.</span> <span class="toc-nav-text">继承类型</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#动态绑定"><span class="toc-nav-number">5.3.</span> <span class="toc-nav-text">动态绑定</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#虚函数"><span class="toc-nav-number">5.4.</span> <span class="toc-nav-text">虚函数</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#纯虚函数与抽象基类"><span class="toc-nav-number">5.4.1.</span> <span class="toc-nav-text">纯虚函数与抽象基类</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#流"><span class="toc-nav-number">6.</span> <span class="toc-nav-text">流</span></a></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#C++" title="C++">C++</a>
                        
                          <a class="tag" href="/tags/#学习笔记" title="学习笔记">学习笔记</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
            </div>
        </div>
    </div>
</article>









    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                

                
                    <li>
                        <a target="_blank" href="https://github.com/XzdDong">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; xzdDong 2020 
                    <br>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://yoursite.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<!-- img src="http://yoursite.com/img/icon_wechat.png" width="0" height="0" / -->
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
